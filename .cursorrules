# KangarooPOS - Cursor Rules for Codebase Integrity

## Project Context
KangarooPOS is an offline-first Point of Sale system with hybrid cloud/edge database architecture.
- **Stack**: Node.js 20 + TypeScript 5.9, Supabase (PostgreSQL), SQLite (better-sqlite3)
- **Architecture**: Hybrid Database Adapter Pattern, Service Layer, Custom Router
- **Code Quality**: Biome (linting/formatting), Vitest (testing), Pino (logging), Zod (validation)

---

## Core Principles

### 1. Architecture Integrity
- **ALWAYS** use the hybrid adapter (`db` from `@/db`) - NEVER directly import `cloudDb` or `edgeDb` in services/routes
- **ALWAYS** extend `BaseService` for all service classes
- **ALWAYS** use the custom router pattern - no Express/Hono imports
- **NEVER** bypass the service layer - routes should only call services, never database directly
- **NEVER** mix database adapters - one service = one adapter instance

### 2. Type Safety
- **ALWAYS** use TypeScript strict mode patterns
- **ALWAYS** define explicit types for service inputs/outputs (use `interface`, not `type` for public APIs)
- **ALWAYS** validate external inputs with Zod schemas in routes
- **NEVER** use `any` - use `unknown` + type guards if needed
- **ALWAYS** use `as const` for literal types in schemas

### 3. Error Handling
- **ALWAYS** use custom error classes from `@/utils/errors`
- **ALWAYS** throw errors, never return error objects (except database adapter results)
- **ALWAYS** include context in error messages (resource name, ID, operation)
- **NEVER** throw raw strings or Error instances - use AppError subclasses
- **ALWAYS** handle database errors and convert to domain errors in services

### 4. Database Patterns
- **ALWAYS** use `db` (hybrid adapter) in services - it handles online/offline automatically
- **ALWAYS** check `result.error` before using `result.data` from database operations
- **ALWAYS** use database-level pagination (limit/offset in SelectOptions) - NEVER fetch all and paginate in memory
- **ALWAYS** use transactions for multi-step operations (orders, payments, inventory transfers)
- **NEVER** assume transaction support in cloud adapter - it's simulated, not ACID
- **ALWAYS** handle offline scenarios - check `db.isOnline` when needed for user feedback

### 5. Service Layer Patterns
- **ALWAYS** extend `BaseService` and use `this.db` (never import db directly)
- **ALWAYS** extract account_id/user_id from request in route handlers, pass to services
- **ALWAYS** return domain objects, never raw database results
- **ALWAYS** validate business rules in services, not routes
- **ALWAYS** use descriptive method names: `getInventory`, `createOrder`, `adjustStock`
- **NEVER** expose database adapter types in service public APIs

### 6. Route Patterns
- **ALWAYS** use middleware array: `[authenticate(), requireRole(...), validateBody(schema)]`
- **ALWAYS** extract `accountId` from `req.accountId!` (set by auth middleware)
- **ALWAYS** use `successResponse()` or `paginatedResponse()` from `@/api/response`
- **ALWAYS** validate inputs with Zod schemas before service calls
- **ALWAYS** handle errors by throwing - router will catch and format
- **NEVER** put business logic in route handlers - delegate to services

### 7. Sync & Offline Patterns
- **ALWAYS** use hybrid adapter - it automatically queues writes for sync when offline
- **ALWAYS** check `db.isOnline` status for user-facing messages
- **ALWAYS** use sync service for manual sync operations
- **ALWAYS** handle sync conflicts with proper resolution strategies
- **NEVER** write to cloud-only tables when offline (products, categories, etc.)

### 8. Validation & Security
- **ALWAYS** validate all external inputs with Zod schemas
- **ALWAYS** use `validateBody`, `validateQuery`, `validateParams` middleware
- **ALWAYS** check account_id isolation - users can only access their account's data
- **ALWAYS** use RBAC middleware (`requireRole`) for protected routes
- **ALWAYS** use `authenticate()` or `optionalAuth()` middleware
- **NEVER** trust client input - validate everything

### 9. Logging & Observability
- **ALWAYS** use structured logging with `logger` from `@/utils/logger`
- **ALWAYS** include context: `logger.info({ accountId, orderId }, 'Order created')`
- **ALWAYS** log errors with full context: `logger.error({ error, requestId }, 'Operation failed')`
- **ALWAYS** use appropriate log levels: `error`, `warn`, `info`, `debug`
- **NEVER** log sensitive data (passwords, tokens, full request bodies)

### 10. Testing Requirements
- **ALWAYS** write tests for new services (unit tests)
- **ALWAYS** write tests for critical flows (sync, transactions, auth)
- **ALWAYS** use Vitest - test files: `*.test.ts` or `*.spec.ts`
- **ALWAYS** test error cases, not just happy paths
- **ALWAYS** mock database adapters in unit tests
- **NEVER** commit code without tests for new business logic

### 11. Performance
- **ALWAYS** use database-level pagination (limit/offset in SelectOptions)
- **ALWAYS** use indexes for frequently queried columns (account_id, store_id, etc.)
- **ALWAYS** batch operations when possible (insertMany, bulk updates)
- **ALWAYS** avoid N+1 queries - use joins or batch selects
- **NEVER** fetch all records and filter in memory
- **ALWAYS** consider caching for frequently accessed, rarely changed data

### 12. Code Style
- **ALWAYS** follow Biome configuration (single quotes, semicolons, 2-space indent)
- **ALWAYS** use `export` for public APIs, avoid default exports
- **ALWAYS** organize imports: external → internal, grouped by type
- **ALWAYS** use JSDoc comments for public service methods
- **ALWAYS** use descriptive variable names - avoid abbreviations
- **NEVER** use `// @ts-ignore` or `// @ts-expect-error` without explanation

### 13. File Structure
```
src/
  api/
    middleware/     # Request middleware (auth, validation, rate-limit)
    routes/         # Route handlers (thin, delegate to services)
    response.ts     # Response helpers
    router.ts       # Custom router
  auth/             # Authentication logic
  config/           # Configuration (env, database clients)
  db/               # Database adapters (cloud, edge, hybrid)
  services/         # Business logic (one folder per domain)
    {domain}/
      {domain}.service.ts
      index.ts
  types/            # TypeScript types
  utils/            # Utilities (logger, errors, datetime, etc.)
```

### 14. Naming Conventions
- **Services**: `{Domain}Service` (e.g., `InventoryService`, `OrderService`)
- **Routes**: `register{Domain}Routes` (e.g., `registerInventoryRoutes`)
- **Interfaces**: PascalCase (e.g., `GetInventoryInput`, `CreateOrderInput`)
- **Files**: kebab-case (e.g., `inventory.service.ts`, `order.service.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `CLOUD_ONLY_WRITE_TABLES`)
- **Database tables**: snake_case (e.g., `order_items`, `sync_journal`)

### 15. Database Schema Patterns
- **ALWAYS** use UUID primary keys (`id UUID PRIMARY KEY`)
- **ALWAYS** include `account_id` for multi-tenant tables
- **ALWAYS** include `created_at` and `updated_at` timestamps
- **ALWAYS** use `TIMESTAMPTZ` for timestamps
- **ALWAYS** include `is_active` boolean for soft deletes
- **ALWAYS** use foreign keys with appropriate CASCADE rules

### 16. Transaction Patterns
- **ALWAYS** use transactions for multi-step operations
- **ALWAYS** handle transaction errors and rollback
- **ALWAYS** be aware: cloud adapter transactions are simulated (not ACID)
- **ALWAYS** test transaction rollback scenarios
- **NEVER** nest transactions - use single transaction for entire operation

### 17. Sync Patterns
- **ALWAYS** let hybrid adapter handle sync queueing automatically
- **ALWAYS** use sync service for manual sync operations
- **ALWAYS** handle sync conflicts with proper resolution
- **ALWAYS** test offline → online sync scenarios
- **NEVER** manually manipulate sync_journal table

### 18. Documentation
- **ALWAYS** add JSDoc comments for public service methods
- **ALWAYS** document complex business logic
- **ALWAYS** document API endpoints (method, path, auth, params)
- **ALWAYS** update README for new features
- **NEVER** leave TODO comments without issue references

### 19. Dependencies
- **ALWAYS** use existing dependencies - avoid adding new ones without justification
- **ALWAYS** check for security vulnerabilities: `npm audit`
- **ALWAYS** pin dependency versions in package.json
- **NEVER** add heavy frameworks (Express, NestJS) - use custom router
- **NEVER** add ORMs (Prisma, TypeORM) - use adapter pattern

### 20. Migration & Deployment
- **ALWAYS** use Supabase migrations for schema changes
- **ALWAYS** update edge schema when cloud schema changes
- **ALWAYS** test migrations on staging first
- **ALWAYS** include rollback scripts for critical migrations
- **NEVER** modify production schema without migration

---

## Code Examples

### ✅ CORRECT: Service Pattern
```typescript
// src/services/inventory/inventory.service.ts
import { db } from '../../db';
import { BaseService } from '../base.service';
import { NotFoundError, ValidationError } from '../../utils/errors';

export interface GetInventoryInput {
  account_id: string;
  store_id?: string;
}

export class InventoryService extends BaseService {
  /**
   * Get inventory records for an account
   */
  async getInventory(input: GetInventoryInput): Promise<Inventory[]> {
    const where = [{ column: 'account_id', operator: '=' as const, value: input.account_id }];
    if (input.store_id) {
      where.push({ column: 'store_id', operator: '=' as const, value: input.store_id });
    }

    const result = await this.db.select<Inventory>('inventory', { where });
    if (result.error) {
      throw new Error(`Failed to fetch inventory: ${result.error}`);
    }
    return result.data;
  }
}
```

### ✅ CORRECT: Route Pattern
```typescript
// src/api/routes/inventory.ts
import { authenticate, requireRole } from '../../auth/middleware';
import { InventoryService } from '../../services/inventory/inventory.service';
import { validateQuery } from '../middleware/validation';
import { paginatedResponse } from '../response';
import { z } from 'zod';

const querySchema = z.object({
  store_id: z.string().uuid().optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().max(100).default(50)
});

export function registerInventoryRoutes(router: Router): void {
  router.get(
    '/api/v1/inventory',
    async (req: ApiRequest, res: ApiResponse) => {
      const accountId = req.accountId!;
      const query = querySchema.parse(req.query || {});

      const result = await inventoryService.getInventory(
        { account_id: accountId, store_id: query.store_id },
        { limit: query.limit, offset: (query.page - 1) * query.limit }
      );

      paginatedResponse(res, result.data, result.count || 0, query.page, query.limit, {
        requestId: req.requestId
      });
    },
    [authenticate(), requireRole('owner', 'admin', 'manager'), validateQuery(querySchema)]
  );
}
```

### ❌ WRONG: Direct Database Access in Route
```typescript
// DON'T DO THIS
router.get('/api/v1/inventory', async (req, res) => {
  const result = await db.select('inventory', { where: [...] }); // ❌ Business logic in route
  res.json(result);
});
```

### ❌ WRONG: Using Cloud/Edge Adapters Directly
```typescript
// DON'T DO THIS
import { cloudDb } from '@/db/cloud-adapter'; // ❌ Bypass hybrid adapter
const result = await cloudDb.select('inventory', {});
```

### ❌ WRONG: Memory Pagination
```typescript
// DON'T DO THIS
const all = await service.getInventory({ account_id }); // ❌ Fetches all
const paginated = all.slice(start, start + limit); // ❌ Memory pagination
```

---

## Checklist for New Features

Before implementing any feature, ensure:

- [ ] Service extends `BaseService` and uses `this.db`
- [ ] Route uses middleware array with auth/validation
- [ ] Input validation with Zod schemas
- [ ] Error handling with custom error classes
- [ ] Database-level pagination (if listing data)
- [ ] Account isolation enforced
- [ ] RBAC middleware applied
- [ ] Structured logging with context
- [ ] Unit tests written
- [ ] Offline scenario considered (if applicable)
- [ ] JSDoc comments for public methods
- [ ] No direct database access in routes
- [ ] No memory pagination
- [ ] No `any` types
- [ ] Biome formatting applied

---

## Enforcement

When suggesting code changes:
1. **ALWAYS** follow these rules strictly
2. **ALWAYS** point out violations in code review
3. **ALWAYS** suggest fixes that align with these patterns
4. **ALWAYS** maintain consistency with existing codebase
5. **NEVER** suggest breaking changes to architecture patterns
6. **NEVER** suggest adding heavy dependencies
7. **NEVER** suggest shortcuts that bypass service layer
8. **NEVER** suggest memory pagination
9. **ALWAYS** prioritize code integrity over speed
10. **ALWAYS** ensure offline-first compatibility

---

## Quick Reference

| Pattern | Rule |
|---------|------|
| Database Access | Always use `db` (hybrid adapter) via `this.db` in services |
| Service Class | Always extend `BaseService` |
| Route Handler | Always use middleware array, delegate to services |
| Error Handling | Always throw custom error classes |
| Validation | Always use Zod schemas with middleware |
| Pagination | Always use database-level (limit/offset) |
| Logging | Always use structured logging with context |
| Testing | Always write tests for new services |
| Types | Always explicit types, never `any` |
| Offline | Always consider offline scenarios |

---

## Rule Improvement & Continuous Learning

This section defines how these rules evolve based on emerging patterns, code reviews, and best practices discovered in the codebase.

### Rule Improvement Triggers

Monitor and update rules when:

- **New Code Patterns**: A pattern appears in 3+ files that isn't covered by existing rules
- **Repeated Implementations**: Similar code structures appear across multiple services/routes
- **Common Error Patterns**: Same bugs or violations appear repeatedly in code reviews
- **New Libraries/Tools**: New dependencies are consistently used (e.g., new validation library, caching solution)
- **Emerging Best Practices**: Team discovers better patterns through experimentation
- **Architecture Evolution**: Hybrid adapter patterns evolve, new sync strategies emerge
- **Performance Issues**: Common performance anti-patterns are identified
- **Security Concerns**: New attack vectors or security patterns are discovered

### Analysis Process

When analyzing code for rule improvements:

1. **Pattern Detection**:
   - Compare new code with existing rules
   - Identify patterns that should be standardized
   - Look for deviations from established patterns
   - Check for consistent error handling patterns across services

2. **Code Review Patterns**:
   - Monitor repeated feedback in PR reviews
   - Track common questions from developers
   - Identify frequently missed checklist items
   - Note patterns that cause confusion

3. **Test Patterns**:
   - Observe test structure consistency
   - Identify missing test scenarios
   - Note common mocking patterns
   - Track test coverage gaps

4. **Database Patterns**:
   - Monitor hybrid adapter usage patterns
   - Track offline/online handling patterns
   - Identify sync conflict resolution strategies
   - Note transaction usage patterns

5. **Service Patterns**:
   - Compare service method structures
   - Identify common input/output patterns
   - Track validation patterns
   - Note error handling consistency

### Rule Updates

#### Add New Rules When:

- A new technology/pattern is used in 3+ files (e.g., new caching strategy, new validation approach)
- Common bugs could be prevented by a rule (e.g., forgetting to check `result.error`)
- Code reviews repeatedly mention the same feedback (e.g., "missing account_id check")
- New security or performance patterns emerge (e.g., new sync strategy, new pagination approach)
- Architecture decisions need to be codified (e.g., new adapter pattern, new middleware pattern)

#### Modify Existing Rules When:

- Better examples exist in the codebase (update code examples with real implementations)
- Additional edge cases are discovered (e.g., new offline scenarios, new error types)
- Related rules have been updated (ensure consistency)
- Implementation details have changed (e.g., BaseService API changes, router API changes)
- Patterns have evolved (e.g., new sync conflict resolution, new transaction patterns)

#### Example Pattern Recognition

```typescript
// If you see repeated patterns like:
const where = [
  { column: 'account_id', operator: '=' as const, value: accountId }
];
if (storeId) {
  where.push({ column: 'store_id', operator: '=' as const, value: storeId });
}

// Consider adding to Database Patterns section:
// - Standard where clause construction pattern
// - Account isolation enforcement pattern
// - Optional filter pattern
```

```typescript
// If you see repeated error handling:
if (result.error) {
  throw new Error(`Failed to fetch ${resource}: ${result.error}`);
}

// Consider standardizing:
// - Error message format
// - Error context inclusion
// - Error type selection (AppError subclasses)
```

```typescript
// If you see repeated service patterns:
export class XService extends BaseService {
  async getX(input: GetXInput, options?: SelectOptions): Promise<X[]> {
    const where = [{ column: 'account_id', operator: '=' as const, value: input.account_id }];
    // ... filtering logic
    const result = await this.db.select<X>('x_table', { ...options, where });
    if (result.error) {
      throw new Error(`Failed to fetch X: ${result.error}`);
    }
    return result.data;
  }
}

// Consider documenting:
// - Standard service method structure
// - Standard input/output interfaces
// - Standard error handling
// - Standard pagination support
```

### Rule Quality Checks

Before adding or modifying rules, ensure:

- **Actionable**: Rules should be specific and enforceable (not vague like "write good code")
- **Examples from Codebase**: Examples should come from actual implementations in `src/`
- **Up-to-Date References**: References to files, classes, functions should match current codebase
- **Consistent Enforcement**: Patterns should be consistently applied across the codebase
- **Testable**: Rules should be verifiable (can be checked in code reviews or automated)
- **Context-Aware**: Rules should consider offline-first, hybrid adapter, and sync constraints

### Continuous Improvement Process

1. **Monitor Code Reviews**:
   - Track common feedback patterns
   - Note repeated violations
   - Identify missing rule coverage

2. **Track Development Questions**:
   - Common "how do I..." questions indicate missing documentation
   - Repeated clarifications suggest unclear rules
   - New patterns emerge from questions

3. **Update After Major Refactors**:
   - When BaseService changes, update service patterns
   - When router changes, update route patterns
   - When adapter changes, update database patterns

4. **Link Related Rules**:
   - Cross-reference related patterns (e.g., service → route → validation)
   - Maintain consistency across rule sections
   - Update examples when referenced code changes

5. **Document Breaking Changes**:
   - When rules change significantly, document migration path
   - Update examples to reflect new patterns
   - Mark deprecated patterns clearly

### Rule Deprecation

When deprecating rules:

1. **Mark as Deprecated**: Clearly indicate deprecated patterns
2. **Provide Migration Path**: Show how to migrate from old to new pattern
3. **Update References**: Remove or update references to deprecated patterns
4. **Document Reason**: Explain why pattern is deprecated (security, performance, maintainability)

Example:
```markdown
### ⚠️ DEPRECATED: Direct Database Access in Routes
**Reason**: Bypasses service layer, breaks offline-first architecture
**Migration**: Move logic to service, call service from route
**Removed**: 2025-02-XX
```

### Documentation Synchronization

Keep documentation synchronized with code:

- **Code Examples**: Update examples when actual implementations change
- **File References**: Update paths when files are moved/renamed
- **API References**: Update when BaseService, Router, or adapter APIs change
- **Pattern Examples**: Use real code from `src/` services and routes
- **Version Tracking**: Update "Last Updated" date when rules change

### Pattern Recognition Examples

#### Service Pattern Recognition

If you see this pattern in multiple services:
```typescript
async getX(input: GetXInput, options?: SelectOptions): Promise<X[]> {
  const where = [{ column: 'account_id', operator: '=' as const, value: input.account_id }];
  // ... filters
  const result = await this.db.select<X>('x_table', { ...options, where });
  if (result.error) throw new Error(`Failed: ${result.error}`);
  return result.data;
}
```

**Action**: Document as standard service getter pattern in Section 5 (Service Layer Patterns)

#### Route Pattern Recognition

If you see this pattern in multiple routes:
```typescript
router.get('/api/v1/x', async (req, res) => {
  const accountId = req.accountId!;
  const query = querySchema.parse(req.query || {});
  const result = await service.getX({ account_id: accountId, ...query });
  paginatedResponse(res, result.data, result.count || 0, query.page, query.limit);
}, [authenticate(), requireRole('owner', 'admin'), validateQuery(querySchema)]);
```

**Action**: Document as standard route pattern in Section 6 (Route Patterns)

#### Error Handling Pattern Recognition

If you see inconsistent error handling:
```typescript
// Sometimes:
if (result.error) throw new Error(result.error);

// Sometimes:
if (result.error) throw new NotFoundError('Resource', id);

// Sometimes:
if (result.error) {
  logger.error({ error: result.error });
  throw new Error('Operation failed');
}
```

**Action**: Standardize error handling pattern and add to Section 3 (Error Handling)

### Rule Versioning

Track rule changes:

- **Version**: Increment when rules change significantly
- **Last Updated**: Update date when rules are modified
- **Changelog**: Document major changes (optional, in comments)

---

**Last Updated**: 2025-01-XX
**Version**: 1.0.0
**Maintainer**: Development Team

---

## Quick Reference: Rule Improvement Workflow

1. **Detect Pattern**: Identify recurring pattern or issue (3+ occurrences)
2. **Analyze**: Compare with existing rules, check codebase examples
3. **Draft Rule**: Write specific, actionable rule with real examples
4. **Quality Check**: Ensure actionable, testable, consistent
5. **Update Examples**: Use actual code from `src/` directory
6. **Cross-Reference**: Link to related rules, update related sections
7. **Document**: Update version, date, changelog if needed
8. **Enforce**: Apply in code reviews, update checklist
